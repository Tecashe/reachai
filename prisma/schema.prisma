generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  clerkId   String   @unique
  email     String   @unique
  name      String?
  firstName String?
  lastName  String?
  imageUrl  String?
  role      UserRole @default(USER)

  // Subscription
  subscriptionTier   SubscriptionTier   @default(FREE)
  subscriptionId     String?
  customerId         String?
  subscriptionStatus SubscriptionStatus @default(INACTIVE)
  currentPeriodEnd   DateTime?

  emailCredits    Int @default(100)
  researchCredits Int @default(50)

  // Usage tracking
  emailsSentThisMonth Int @default(0)
  prospectsThisMonth  Int @default(0)
  aiCreditsUsed       Int @default(0)

  // Onboarding questionnaire
  companyName                      String?
  userRole                         String? // "founder", "sales", "marketing", "other"
  useCase                          String? // "finding_customers", "partnerships", "recruiting", "other"
  monthlyVolume                    String? // "under_500", "500_2000", "over_2000"
  onboardingCompletedQuestionnaire Boolean @default(false)

  // Onboarding progress
  hasCreatedCampaign      Boolean   @default(false)
  hasAddedProspects       Boolean   @default(false)
  hasResearchedProspects  Boolean   @default(false)
  hasGeneratedEmail       Boolean   @default(false)
  hasSentEmail            Boolean   @default(false)
  hasViewedAnalytics      Boolean   @default(false)
  onboardingCompletedAt   DateTime?
  lastOnboardingEmailSent DateTime?
  onboardingEmailsSent    Int       @default(0)

  // Settings
  timezone         String  @default("America/New_York")
  emailSignature   String?
  defaultFromName  String?
  defaultFromEmail String?

  preferences Json? // { scrapingMode: "FAST" | "DEEP", ... }

  subscription    Subscription?
  sendingAccounts SendingAccount[]
  prospectFolders ProspectFolder[]
  workspaceDelegations WorkspaceDelegation[]

  // Relationships
  sequences          Sequence[]
  campaigns          Campaign[]
  prospects          Prospect[]
  webhooks           Webhook[]
  emailTemplates     EmailTemplate[]
  integrations       Integration[]
  auditLogs          AuditLog[]
  teamMembers        TeamMember[]
  notifications      Notification[]
  apiKeys            ApiKey[]
  creditTransactions CreditTransaction[]
  creditPurchases    CreditPurchase[]
  domains            Domain[]

  // Last time we sent low credit warning
  lastCreditWarning DateTime?
  settings          UserSettings?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clerkId])
  @@index([email])
}

model Subscription {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  stripeCustomerId       String   @unique
  stripeSubscriptionId   String   @unique
  stripePriceId          String
  stripeCurrentPeriodEnd DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Campaign {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name        String
  description String?
  status      CampaignStatus @default(DRAFT)

  wizardStep           String @default("prospects") // "prospects", "research", "generate", "review", "launch"
  wizardData           Json? // Store step-specific progress data
  wizardCompletedSteps Json? // Array of completed step IDs

  // Campaign settings
  dailySendLimit  Int     @default(50)
  sendingSchedule Json? // { days: [], startTime: "", endTime: "" }
  trackOpens      Boolean @default(true)
  trackClicks     Boolean @default(true)

  // Link to main Sequence for this campaign
  sequenceId String?

  sequenceAutomationRules SequenceAutomationRule[]

  // AI settings
  researchDepth        ResearchDepth        @default(STANDARD)
  personalizationLevel PersonalizationLevel @default(MEDIUM)
  toneOfVoice          String               @default("professional")

  automationRules Json?

  // Stats
  totalProspects  Int @default(0)
  emailsSent      Int @default(0)
  emailsDelivered Int @default(0)
  emailsOpened    Int @default(0)
  emailsClicked   Int @default(0)
  emailsReplied   Int @default(0)
  emailsBounced   Int @default(0)

  // Relationships
  prospects           Prospect[]
  emailSequences      EmailSequence[]
  analytics           Analytics[]
  replies             EmailReply[]
  subsequenceTriggers SubsequenceTrigger[]

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  launchedAt DateTime?

  @@index([userId])
  @@index([status])
  @@index([sequenceId])
}

model Prospect {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  campaignId String?
  campaign   Campaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)

  folderId String?
  folder   ProspectFolder? @relation("ProspectToFolder", fields: [folderId], references: [id], onDelete: SetNull)

  // Basic info
  email       String
  firstName   String?
  lastName    String?
  company     String?
  jobTitle    String?
  linkedinUrl String?
  websiteUrl  String?

  // Enriched data
  companySize String?
  industry    String?
  location    String?
  phoneNumber String?

  // AI research data
  researchData          Json? // Scraped data, insights, talking points
  qualityScore          Int? // 0-100
  personalizationTokens Json? // Key-value pairs for template variables
  retryQueue            RetryQueue[]

  generatedEmail Json? // { subject: string, body: string, qualityScore: number, personalizationScore: number }

  // Email status
  status          ProspectStatus @default(ACTIVE)
  currentStep     Int            @default(0)
  lastContactedAt DateTime?

  // Engagement - detailed tracking
  emailsReceived Int       @default(0) // Total emails sent to this prospect
  emailsOpened   Int       @default(0) // Total times emails were opened
  emailsClicked  Int       @default(0) // Total times links were clicked
  emailsReplied  Int       @default(0) // Total replies received
  replied        Boolean   @default(false) // Has replied at least once
  repliedAt      DateTime?
  bounced        Boolean   @default(false)
  unsubscribed   Boolean   @default(false)

  crmId       String? // External CRM ID (HubSpot, Salesforce, etc.)
  crmType     String? // Type of CRM (hubspot, salesforce, pipedrive)
  crmSyncedAt DateTime? // Last sync timestamp
  crmData     Json? // Raw CRM data
  dealId      String? // Associated deal ID in CRM
  dealScore   Float? // AI deal score 0-100

  // Relationships
  emailLogs        EmailLog[]
  sendingSchedules SendingSchedule[]
  replies          EmailReply[]
  folders          ProspectInFolder[]

  timezone           String?
  timezoneDetectedAt DateTime?

  lastReplyAt DateTime?
  replyCount  Int       @default(0)

  isTrashed Boolean   @default(false)
  trashedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([email, campaignId])
  @@index([userId])
  @@index([campaignId])
  @@index([email])
  @@index([status])
  @@index([crmId])
  @@index([dealScore])
  @@index([isTrashed])
  @@index([folderId])
}

model EmailTemplate {
  id String @id @default(cuid())

  userId      String?
  user        User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  description String?
  category    String? // Will be deprecated in favor of categories relation

  subject String
  body    String @db.Text

  // NEW: Visual enhancements
  thumbnailUrl    String? // Template preview image
  previewImageUrl String? // Full template visualization
  colorScheme     Json? // { primary: "#...", secondary: "#...", accent: "#..." }

  // NEW: Industry & advanced categorization
  industry String? // "saas", "ecommerce", "real_estate", "recruiting", "healthcare", "finance", "education", "nonprofit", "technology", "consulting"
  tags     String[] @default([]) // ["b2b", "enterprise", "follow-up", "cold-outreach"]

  // NEW: Template type & structure
  isSystemTemplate Boolean      @default(false) // Built-in vs user-created
  templateType     TemplateType @default(TEXT) // TEXT, VISUAL, HTML

  // NEW: Drag-and-drop editor data
  editorBlocks  Json? // Block-based editor structure with blocks array
  editorVersion String? @default("1.0")

  // NEW: AI generation metadata
  aiGenerated    Boolean @default(false)
  basePrompt     String? @db.Text // Original prompt used to generate
  aiModel        String? // Model used (e.g., "gpt-4", "claude-3")
  aiPrompt       String? @db.Text // Full prompt with context
  aiGenerationId String? // Track generation session

  // Template variables (existing but enhanced)
  variables Json? // [{ name: "company", required: true, defaultValue: "", description: "" }]

  // NEW: Enhanced stats and engagement
  timesUsed      Int       @default(0)
  avgOpenRate    Float?
  avgReplyRate   Float?
  lastUsedAt     DateTime?
  isFavorite     Boolean   @default(false)
  viewCount      Int       @default(0)
  duplicateCount Int       @default(0) // How many times it's been duplicated

  // NEW: Template categories (many-to-many)
  templateCategories TemplateInCategory[]
  versions           TemplateVersion[]

  // Existing relationships
  emailSequences EmailSequence[]

  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  TemplateBlock TemplateBlock[]

  @@index([userId])
  @@index([category])
  @@index([industry])
  @@index([isSystemTemplate])
  @@index([isFavorite])
  @@index([templateType])
  @@index([timesUsed])
}

model EmailSequence {
  id         String        @id @default(cuid())
  campaignId String
  campaign   Campaign      @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  templateId String
  template   EmailTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  stepNumber Int // 1, 2, 3, etc.
  delayDays  Int @default(2) // Days after previous email

  // Conditions
  sendOnlyIfNotReplied Boolean @default(true)
  sendOnlyIfNotOpened  Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([campaignId, stepNumber])
  @@index([campaignId])
}

model EmailLog {
  id         String   @id @default(cuid())
  prospectId String
  prospect   Prospect @relation(fields: [prospectId], references: [id], onDelete: Cascade)

  // Email details
  subject   String
  body      String @db.Text
  fromEmail String
  toEmail   String

  // Status
  status      EmailStatus @default(QUEUED)
  sentAt      DateTime?
  deliveredAt DateTime?
  openedAt    DateTime?
  clickedAt   DateTime?
  repliedAt   DateTime?
  bouncedAt   DateTime?

  // Tracking
  opens      Int     @default(0)
  clicks     Int     @default(0)
  trackingId String? @unique

  recipientTimezone   String?
  sentInBusinessHours Boolean @default(false)

  variant      String? // "A", "B", "C" for A/B testing
  variantGroup String? // Group ID for related variants

  // Error handling
  errorMessage String?
  retryCount   Int     @default(0)

  // Provider info
  provider   String? // "resend", "gmail", "outlook"
  providerId String? // External ID from email provider

  sendingAccountId String?
  sendingAccount   SendingAccount? @relation(fields: [sendingAccountId], references: [id], onDelete: SetNull)

  validationId String?
  validation   EmailValidationResult? @relation(fields: [validationId], references: [id], onDelete: SetNull)

  bounces       EmailBounce[]
  webhookEvents WebhookEvent[]
  replies       EmailReply[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([prospectId])
  @@index([status])
  @@index([sentAt])
  @@index([sendingAccountId])
  @@index([variantGroup])
}

model Integration {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type IntegrationType
  name String

  // Credentials (encrypted)
  credentials Json // Encrypted API keys, tokens, etc.

  // Status
  isActive     Boolean   @default(true)
  lastSyncedAt DateTime?

  // Settings
  settings Json? // Provider-specific settings

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, type])
  @@index([userId])
}

model Analytics {
  id         String   @id @default(cuid())
  campaignId String
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  date DateTime @default(now())

  // Daily metrics
  emailsSent      Int @default(0)
  emailsDelivered Int @default(0)
  emailsOpened    Int @default(0)
  emailsClicked   Int @default(0)
  emailsReplied   Int @default(0)
  emailsBounced   Int @default(0)

  // Calculated rates
  deliveryRate Float?
  openRate     Float?
  clickRate    Float?
  replyRate    Float?
  bounceRate   Float?

  createdAt DateTime @default(now())

  @@unique([campaignId, date])
  @@index([campaignId])
  @@index([date])
}

model AuditLog {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  action     String // "campaign.created", "prospect.imported", etc.
  entityType String // "campaign", "prospect", "template"
  entityId   String?

  metadata  Json? // Additional context
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([entityType])
  @@index([createdAt])
}

model TeamMember {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  email       String
  role        TeamRole @default(MEMBER)
  permissions Json? // Granular permissions

  invitationToken  String?   @unique
  invitationExpiry DateTime?

  invitedAt  DateTime     @default(now())
  acceptedAt DateTime?
  status     InviteStatus @default(PENDING)

  invitedBy String? // User ID of inviter

  @@unique([userId, email])
  @@index([userId])
  @@index([invitationToken])
  @@index([status])
}

model Notification {
  id     String @id @default(cuid())
  userId String

  type    NotificationType
  title   String
  message String           @db.Text

  // Related entity
  entityType String? // "campaign", "prospect", "email"
  entityId   String?

  severity         String? // "info", "warning", "critical", "success"
  relatedAccountId String? // Link to SendingAccount for warmup notifications

  // Status
  read   Boolean   @default(false)
  isRead Boolean   @default(false)
  readAt DateTime?

  // Metadata
  metadata  Json? // Additional context
  actionUrl String? // Link to related page

  createdAt DateTime @default(now())
  User      User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([isRead])
  @@index([read])
  @@index([createdAt])
}

model ApiKey {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name      String
  key       String @unique // Hashed API key
  keyPrefix String // First 8 chars for display (e.g., "sk_live_")

  // Permissions
  scopes Json // ["campaigns:read", "prospects:write", etc.]

  // Status
  isActive  Boolean   @default(true)
  expiresAt DateTime?

  // Usage tracking
  lastUsedAt   DateTime?
  requestCount Int       @default(0)

  // Rate limiting
  rateLimit   Int             @default(1000) // Requests per hour
  requestLogs ApiRequestLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([key])
  @@index([keyPrefix])
}

model ApiRequestLog {
  id       String @id @default(cuid())
  apiKeyId String
  apiKey   ApiKey @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  endpoint     String
  method       String
  statusCode   Int
  responseTime Int // milliseconds

  createdAt DateTime @default(now())

  @@index([apiKeyId])
  @@index([createdAt])
}

model SendingAccount {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Account details
  name      String
  email     String
  provider  String // "resend", "gmail", "outlook"
  ipAddress String?

  connectionMethod String? // nullable for backwards compatibility

  smtpHost     String?
  smtpPort     Int?
  smtpSecure   Boolean? @default(false)
  smtpUsername String?
  smtpPassword String?  @db.Text

  imapTls      Boolean? @default(true)
  imapUsername String?
  imapPassword String?  @db.Text

  oauthProvider     String?
  oauthRefreshToken String?   @db.Text
  oauthAccessToken  String?   @db.Text
  oauthTokenExpiry  DateTime?

  imapHost String?
  imapPort Int?    @default(993)

  // Credentials (encrypted)
  credentials Json // API keys, OAuth tokens, etc.

  // Rate limiting
  dailyLimit         Int      @default(50)
  hourlyLimit        Int      @default(10)
  emailsSentToday    Int      @default(0)
  emailsSentThisHour Int      @default(0)
  lastResetDate      DateTime @default(now())
  lastResetHour      DateTime @default(now())

  warmupEnabled    Boolean     @default(true)
  warmupStage      WarmupStage @default(NEW)
  warmupStartDate  DateTime    @default(now())
  warmupDailyLimit Int         @default(20)
  warmupProgress   Int         @default(0) // Days in current stage

  peerWarmupEnabled Boolean @default(false) // Enabled for stages WARM+
  peerWarmupOptIn   Boolean @default(false) // User opted into peer network

  isActive          Boolean   @default(true)
  healthScore       Int       @default(100) // 0-100
  bounceRate        Float     @default(0)
  spamComplaintRate Float     @default(0)
  replyRate         Float     @default(0)
  openRate          Float     @default(0)
  lastHealthCheck   DateTime?
  pausedReason      String?
  pausedAt          DateTime?
  lastWarmupAt      DateTime?
  lastVerifiedAt    DateTime?

  connectionType   String? // "oauth", "smtp", "workspace-delegation"
  workspaceDomain  String? // For workspace delegation (e.g., "company.com")
  delegationStatus String? // "pending", "verified", "failed"
 

  rotatedAt     DateTime? // Last time account was rotated due to health issues
  rotationCount Int       @default(0) // Number of times account has been rotated

  domainReputation Json? // SPF, DKIM, DMARC status
  lastDomainCheck  DateTime?
  blacklistStatus  Json? // Blacklist check results

  domainId String?
  domain   Domain? @relation(fields: [domainId], references: [id])

  // Relationships
  webhookEvents  WebhookEvent[]
  retryQueue     RetryQueue[]
  emailLogs      EmailLog[]
  schedules      SendingSchedule[]
  bounces        EmailBounce[]
  replies        EmailReply[]
  warmupSessions WarmupSession[]

  warmupThreadsInitiated WarmupThread[]       @relation("ThreadInitiator")
  warmupThreadsReceived  WarmupThread[]       @relation("ThreadRecipient")
  reputationProfile      ReputationProfile?
  inboxPlacements        InboxPlacement[]
  strategyAdjustments    StrategyAdjustment[]
  poolMemberships        PoolMembership[]

  // Peer replies this account needs to send
  pendingPeerReplies     WarmupInteraction[]  @relation("PeerReplies")

  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  ProcessedWarmupEmail ProcessedWarmupEmail[]

  @@unique([userId, email])
  @@index([userId])
  @@index([isActive])
  @@index([healthScore])
  @@index([domainId])
  @@index([peerWarmupEnabled])
}

model WorkspaceDelegation {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Domain info
  domain String @unique

  // Delegation status
  status             String  @default("pending") // "pending", "verified", "failed", "expired"
  verificationMethod String? // "auto_test", "manual_test"

  // Service account details
  serviceAccountEmail    String?
  serviceAccountClientId String?
  authorizedScopes       String[] @default([])

  // Verification tracking
  lastVerifiedAt     DateTime?
  lastVerifiedBy     String? // Email of person who verified
  verificationResult String? @db.Text

  // Health monitoring
  healthStatus      String    @default("unknown") // "unknown", "healthy", "degraded", "unhealthy"
  lastHealthCheckAt DateTime?
  healthCheckResult Json?

  // Error tracking
  errorCount Int     @default(0)
  lastError  String? @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt


  @@index([userId])
  @@index([domain])
  @@index([status])
  @@index([healthStatus])
}

model EmailBounce {
  id         String   @id @default(cuid())
  emailLogId String
  emailLog   EmailLog @relation(fields: [emailLogId], references: [id], onDelete: Cascade)

  sendingAccountId String
  sendingAccount   SendingAccount @relation(fields: [sendingAccountId], references: [id], onDelete: Cascade)

  bounceType     BounceType // HARD, SOFT, COMPLAINT
  bounceReason   String?
  diagnosticCode String?

  recipientEmail String
  bouncedAt      DateTime @default(now())

  @@index([sendingAccountId])
  @@index([bounceType])
  @@index([bouncedAt])
}

model EmailReply {
  id         String   @id @default(cuid())
  emailLogId String
  emailLog   EmailLog @relation(fields: [emailLogId], references: [id], onDelete: Cascade)

  sendingAccountId String?
  sendingAccount   SendingAccount? @relation(fields: [sendingAccountId], references: [id], onDelete: SetNull)

  prospectId String
  prospect   Prospect @relation(fields: [prospectId], references: [id], onDelete: Cascade)

  campaignId String?
  campaign   Campaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)

  // Reply content
  subject   String
  body      String @db.Text
  fromEmail String

  // AI analysis
  sentiment   ReplySentiment?
  category    ReplyCategory?
  isAutoReply Boolean         @default(false)

  isRead       Boolean   @default(false)
  snoozedUntil DateTime?
  readAt       DateTime?
  isArchived   Boolean   @default(false)
  archivedAt   DateTime?

  isStarred Boolean   @default(false)
  starredAt DateTime?
  notes     String?   @db.Text

  // Actions taken
  campaignPaused  Boolean @default(false)
  prospectUpdated Boolean @default(false)

  repliedAt  DateTime  @default(now())
  analyzedAt DateTime?

  attachments EmailAttachment[]

  @@index([prospectId])
  @@index([campaignId])
  @@index([sentiment])
  @@index([repliedAt])
  @@index([isRead])
  @@index([isArchived])
  @@index([isStarred])
}

model EmailValidationResult {
  id     String @id @default(cuid())
  userId String

  // Email content
  subject        String
  body           String @db.Text
  recipientEmail String

  // Validation scores (0-100)
  overallScore         Int
  spamScore            Int
  personalizationScore Int
  deliverabilityScore  Int

  // Detailed analysis
  spamTriggers           Json // Array of detected spam triggers
  missingPersonalization Json // Array of missing personalization opportunities
  recommendations        Json // Array of improvement suggestions

  // Metadata
  validatedAt DateTime @default(now())

  // Relationships
  emailLogs EmailLog[]

  @@index([userId])
  @@index([overallScore])
  @@index([validatedAt])
}

model SendingSchedule {
  id     String @id @default(cuid())
  userId String

  // Email details
  prospectId String
  prospect   Prospect @relation(fields: [prospectId], references: [id], onDelete: Cascade)
  campaignId String?

  subject String
  body    String @db.Text

  // Scheduling
  scheduledFor        DateTime
  timezone            String   @default("America/New_York")
  sendInBusinessHours Boolean  @default(true)

  // Account assignment
  sendingAccountId String?
  sendingAccount   SendingAccount? @relation(fields: [sendingAccountId], references: [id], onDelete: SetNull)

  // Status
  status      ScheduleStatus @default(PENDING)
  processedAt DateTime?
  emailLogId  String?

  // Error handling
  errorMessage String?
  retryCount   Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([scheduledFor])
  @@index([status])
  @@index([sendingAccountId])
}

model CreditTransaction {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type       CreditTransactionType
  creditType CreditType // EMAIL or RESEARCH
  amount     Int // Positive for additions, negative for deductions
  balance    Int // Balance after transaction

  // Context
  description String
  entityType  String? // "email", "research", "campaign"
  entityId    String?

  metadata Json? // Additional context

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([type])
  @@index([createdAt])
}

model CreditPurchase {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  packageId   String // "email_1000", "research_100", etc.
  packageName String

  creditType   CreditType
  creditAmount Int

  // Payment
  amount   Int // Amount in cents
  currency String @default("usd")

  stripePaymentIntentId String? @unique
  stripeSessionId       String? @unique

  status PurchaseStatus @default(PENDING)

  completedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model Domain {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Domain details
  domain     String // e.g., mail.company.com
  recordType String @default("subdomain") // "subdomain" or "main"

  // ADD THESE TWO FIELDS:
  emailProviderId String? // "resend", "gmail", "outlook", "custom", etc.
  dkimSelector    String? // DKIM selector (e.g., "default", "k1", "selector1")

  // DNS Records
  dnsRecords Json? // { spf: {...}, dkim: {...}, dmarc: {...} }

  // ... rest of your existing fields remain the same
  isVerified            Boolean   @default(false)
  verifiedAt            DateTime?
  verificationAttempts  Int       @default(0)
  lastVerificationCheck DateTime?

  // Health status
  healthScore          Int                   @default(100)
  deliverabilityHealth DeliverabilityHealth?

  lastHealthCheck DateTime?

  // Blacklist status
  isBlacklisted    Boolean   @default(false)
  blacklistedOn    String[]  @default([])
  blacklistCheckAt DateTime?

  // Bounce tracking
  bounceRate        Float @default(0)
  spamComplaintRate Float @default(0)

  // Associated sending accounts
  sendingAccounts SendingAccount[]

  // Status
  isActive     Boolean   @default(true)
  pausedReason String?
  pausedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, domain])
  @@index([userId])
  @@index([isVerified])
  @@index([isBlacklisted])
  @@index([healthScore])
  @@index([emailProviderId]) // Add index for faster queries
}

model DeliverabilityHealth {
  id       String @id @default(cuid())
  domainId String @unique
  domain   Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)

  // DNS Status
  spfStatus DNSStatus @default(UNKNOWN)
  spfValid  Boolean   @default(false)
  spfRecord String?

  dkimStatus    DNSStatus @default(UNKNOWN)
  dkimValid     Boolean   @default(false)
  dkimSelector  String? // Added single dkimSelector field
  dkimSelectors Json? // Array of DKIM selectors

  dmarcStatus DNSStatus @default(UNKNOWN)
  dmarcValid  Boolean   @default(false)
  dmarcPolicy String?
  dmarcRecord String? // Full DMARC DNS record value

  mxRecordsValid Boolean @default(false)
  mxRecords      Json?

  blacklists String[] @default([]) // Added blacklists field

  // Reputation metrics
  senderReputation  Int @default(0) // 0-100
  gmailReputation   Int @default(0)
  outlookReputation Int @default(0)

  // Engagement metrics (last 30 days)
  avgDeliveryRate      Float?
  avgOpenRate          Float?
  avgClickRate         Float?
  avgReplyRate         Float?
  avgBounceRate        Float?
  avgSpamComplaintRate Float?

  // Alerts
  hasIssues    Boolean    @default(false)
  alertLevel   AlertLevel @default(NONE) // NONE, WARNING, CRITICAL
  alertMessage String?

  // Last checks
  lastFullCheck       DateTime?
  lastReputationCheck DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([domainId])
  @@index([alertLevel])
}

model DomainVerificationRecord {
  id     String @id @default(cuid())
  userId String

  domain     String
  recordType String // "SPF", "DKIM", "DMARC"

  // Generated record
  recordName  String // DNS name
  recordValue String @db.Text // DNS value

  // Verification
  isVerified Boolean   @default(false)
  verifiedAt DateTime?

  // ADD THIS FIELD:
  lastMessage String? // Last verification message/error

  // Metadata
  selector String? // For DKIM

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([domain])
  @@index([recordType])
}

model ProspectFolder {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name          String
  color         String @default("#3b82f6")
  icon          String @default("Folder")
  prospectCount Int    @default(0)

  isTrashed Boolean   @default(false)
  trashedAt DateTime?

  directProspects Prospect[]         @relation("ProspectToFolder")
  prospects       ProspectInFolder[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([isTrashed])
}

model ProspectInFolder {
  id         String         @id @default(cuid())
  prospectId String
  prospect   Prospect       @relation(fields: [prospectId], references: [id], onDelete: Cascade)
  folderId   String
  folder     ProspectFolder @relation(fields: [folderId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([prospectId, folderId])
  @@index([prospectId])
  @@index([folderId])
}

model WarmupEmail {
  id       String @id @default(cuid())
  email    String @unique
  name     String
  provider String // "gmail", "outlook", "yahoo"

  // Credentials (encrypted)
  imapHost     String
  imapPort     Int
  imapUsername String
  imapPassword String @db.Text // Encrypted

  smtpHost     String?
  smtpPort     Int?
  smtpUsername String?
  smtpPassword String? @db.Text // Encrypted

  // Health
  isActive            Boolean   @default(true)
  lastCheckAt         DateTime?
  lastEmailSentAt     DateTime?
  lastEmailReceivedAt DateTime?

  // Stats
  emailsSent     Int   @default(0)
  emailsReceived Int   @default(0)
  inboxPlacement Float @default(100) // Percentage landing in inbox vs spam

  // Rotation
  lastUsedFor   String? // Which sending account last used this
  cooldownUntil DateTime?

  // Relationships
  warmupSessions     WarmupSession[]
  warmupInteractions WarmupInteraction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isActive])
  @@index([provider])
  @@index([inboxPlacement])
}

model WarmupSession {
  id               String         @id @default(cuid())
  sendingAccountId String
  sendingAccount   SendingAccount @relation(fields: [sendingAccountId], references: [id], onDelete: Cascade)

  warmupEmailId String?
  warmupEmail   WarmupEmail? @relation(fields: [warmupEmailId], references: [id], onDelete: Cascade)

  warmupType       WarmupType @default(POOL) // POOL or PEER
  peerAccountEmail String? // If PEER, the peer account email

  // Session details
  status     WarmupSessionStatus @default(ACTIVE)
  dailyLimit Int                 @default(20)

  // Stats
  emailsSent         Int   @default(0)
  emailsOpened       Int   @default(0)
  emailsReceived     Int   @default(0)
  emailsReplied      Int   @default(0)
  inboxPlacementRate Float @default(0)

  // Schedule
  nextScheduledSend DateTime?
  lastSentAt        DateTime?

  startedAt DateTime  @default(now())
  endedAt   DateTime?

  interactions WarmupInteraction[]

  @@index([sendingAccountId])
  @@index([warmupEmailId])
  @@index([status])
  @@index([warmupType])
}

model WarmupInteraction {
  id        String        @id @default(cuid())
  sessionId String
  session   WarmupSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  sendingAccountId String
  warmupEmailId    String?
  warmupEmail      WarmupEmail? @relation(fields: [warmupEmailId], references: [id], onDelete: Cascade)

  // Email details
  direction WarmupDirection // OUTBOUND or INBOUND
  subject   String
  snippet   String?         @db.Text // First 100 chars of body

  // Tracking
  sentAt      DateTime?
  deliveredAt DateTime?
  openedAt    DateTime?
  repliedAt   DateTime?

  // Inbox placement
  landedInInbox Boolean @default(true)
  landedInSpam  Boolean @default(false)

  // Warmup identification - Unique identifier for warmup email chain (X-Warmup-ID header)
  warmupId String?

  // Email provider ID (for tracking)
  messageId String?

  // Thread tracking fields for conversation grouping
  threadId      String? // Email thread identifier for grouping conversations
  inReplyTo     String? // Message-ID of the email this is replying to
  references    String? // Full thread references for email clients
  webhookEvents WebhookEvent[]
  thread        WarmupThread?  @relation(fields: [threadId], references: [id], onDelete: SetNull)

  // Pending reply tracking
  isPending Boolean @default(false)

  // Peer reply tracking - for true peer-to-peer warmup
  isPendingPeerReply   Boolean         @default(false)  // Waiting for peer to reply
  replyFromAccountId   String?                           // The peer account that should send the reply
  replyFromAccount     SendingAccount? @relation("PeerReplies", fields: [replyFromAccountId], references: [id])
  scheduledAt          DateTime?                         // When the peer reply should be sent
  originalSenderEmail  String?                           // Email of the original sender (for reply addressing)

  createdAt DateTime @default(now())

  @@index([sessionId])
  @@index([warmupEmailId])
  @@index([direction])
  @@index([sentAt])
  @@index([isPending])
  @@index([warmupId])
  @@index([threadId])
  @@index([inReplyTo])
  @@index([isPendingPeerReply, scheduledAt])  // Compound index for peer reply processing
  @@index([replyFromAccountId])
}

// Warmup Thread - Tracks peer-to-peer conversation threads
model WarmupThread {
  id String @id @default(cuid())

  // Participants
  initiatorAccountId String
  initiatorAccount   SendingAccount @relation("ThreadInitiator", fields: [initiatorAccountId], references: [id], onDelete: Cascade)

  recipientAccountId String
  recipientAccount   SendingAccount @relation("ThreadRecipient", fields: [recipientAccountId], references: [id], onDelete: Cascade)

  // Thread metadata
  subject       String            // Original subject line
  topic         String?           // Conversation topic (networking, follow-up, etc.)
  status        WarmupThreadStatus @default(ACTIVE)

  // Conversation tracking
  messageCount      Int       @default(0)   // Total messages in thread
  maxMessages       Int       @default(6)   // Max messages before completing
  lastSenderId      String?                 // Who sent the last message
  nextScheduledAt   DateTime?               // When next message should be sent

  // Thread timing
  responseTimeMin   Int       @default(30)  // Minimum minutes between replies
  responseTimeMax   Int       @default(1440) // Maximum minutes between replies (24 hours)

  // Engagement
  includeLinks      Boolean   @default(false)
  includeAttachments Boolean  @default(false)

  // Stats
  totalOpens        Int       @default(0)
  totalReplies      Int       @default(0)

  // Relationships
  interactions      WarmupInteraction[]

  startedAt         DateTime  @default(now())
  completedAt       DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([initiatorAccountId])
  @@index([recipientAccountId])
  @@index([status])
  @@index([nextScheduledAt])
}

enum WarmupThreadStatus {
  ACTIVE      // Thread is ongoing
  PAUSED      // Temporarily paused
  COMPLETED   // Reached max messages
  FAILED      // Error during thread
}

model WebhookEvent {
  id     String @id @default(cuid())
  userId String

  // Provider info
  provider  String // "sendgrid", "postmark", "mailgun", "resend", "ses"
  eventType String // "delivered", "bounced", "opened", "clicked", "complained"

  // Email identification - Can be warmup OR campaign email
  emailLogId       String?
  emailLog         EmailLog?       @relation(fields: [emailLogId], references: [id], onDelete: SetNull)
  sendingAccountId String?
  sendingAccount   SendingAccount? @relation(fields: [sendingAccountId], references: [id], onDelete: SetNull)

  // For warmup emails - track via warmup interaction
  warmupInteractionId String?
  warmupInteraction   WarmupInteraction? @relation(fields: [warmupInteractionId], references: [id], onDelete: SetNull)

  recipientEmail String
  subject        String?
  messageId      String?

  // Bounce specific
  bounceType     String? // "hard", "soft", "spam"
  bounceReason   String?
  diagnosticCode String? @db.Text

  // Tracking data
  ipAddress  String?
  userAgent  String?
  deviceType String? // "desktop", "mobile", "tablet"
  location   String?

  // Raw data
  rawPayload Json
  signature  String?

  // Processing
  processed   Boolean   @default(false)
  processedAt DateTime?
  error       String?

  createdAt DateTime @default(now())

  @@index([provider])
  @@index([eventType])
  @@index([emailLogId])
  @@index([sendingAccountId])
  @@index([warmupInteractionId])
  @@index([messageId])
  @@index([processed])
  @@index([createdAt])
}

model RetryQueue {
  id     String @id @default(cuid())
  userId String

  // Email info
  sendingAccountId String
  sendingAccount   SendingAccount @relation(fields: [sendingAccountId], references: [id], onDelete: Cascade)

  // Campaign emails only (warmup emails use sessionId)
  prospectId String?
  prospect   Prospect? @relation(fields: [prospectId], references: [id], onDelete: Cascade)

  // Warmup emails only
  sessionId     String? // Links to warmup session
  peerAccountId String? // The peer we're sending warmup email to

  // Email content
  subject   String
  body      String @db.Text
  toEmail   String
  fromEmail String

  // Email type - CRITICAL distinction
  emailType EmailType @default(CAMPAIGN)

  // Retry logic
  attemptCount      Int       @default(0)
  maxAttempts       Int       @default(5)
  nextRetryAt       DateTime
  lastAttemptAt     DateTime?
  backoffMultiplier Float     @default(2.0)

  // Error tracking
  lastError        String? @db.Text
  errorCategory    String? // "rate_limit", "auth_error", "network", "provider_error"
  permanentFailure Boolean @default(false)

  // Status
  status RetryStatus @default(PENDING)

  // Context
  emailLogId String?
  metadata   Json?

  // Result
  succeededAt DateTime?
  failedAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sendingAccountId])
  @@index([status])
  @@index([nextRetryAt])
  @@index([errorCategory])
  @@index([prospectId])
  @@index([sessionId])
  @@index([emailType])
}

//nuevo

model EmailAttachment {
  id           String     @id @default(cuid())
  emailReplyId String
  emailReply   EmailReply @relation(fields: [emailReplyId], references: [id], onDelete: Cascade)

  filename    String
  contentType String // "application/pdf", "image/png", etc.
  size        Int // Size in bytes

  // Storage
  storageUrl String? // Blob storage URL
  storageKey String? // Storage identifier

  // AI analysis
  extractedText String? @db.Text // For PDFs/docs
  isContract    Boolean @default(false)
  isProposal    Boolean @default(false)
  aiSummary     String? @db.Text

  // Preview
  thumbnailUrl     String? // For images/PDFs
  previewGenerated Boolean @default(false)

  // Metadata
  analyzed   Boolean   @default(false)
  analyzedAt DateTime?

  createdAt DateTime @default(now())

  @@index([emailReplyId])
  @@index([isContract])
  @@index([isProposal])
}

model CompanySendLimit {
  id            String @id @default(cuid())
  userId        String
  companyDomain String // e.g., "google.com", "microsoft.com"

  // AI-powered limits
  dailyLimit  Int @default(2) // Max emails per day to this company
  weeklyLimit Int @default(5) // Max emails per week

  // AI learning data
  engagementScore Float     @default(0) // 0-100 based on opens, clicks, replies
  lastEngagement  DateTime?
  totalEmailsSent Int       @default(0)
  totalOpens      Int       @default(0)
  totalClicks     Int       @default(0)
  totalReplies    Int       @default(0)

  // Adaptive limits
  autoAdjust     Boolean @default(true) // AI adjusts limits based on engagement
  suggestedLimit Int? // AI's recommended limit

  // Tracking
  emailsSentToday    Int      @default(0)
  emailsSentThisWeek Int      @default(0)
  lastResetDate      DateTime @default(now())
  lastResetWeek      DateTime @default(now())

  // Company insights
  companySize        String? // "small", "medium", "large", "enterprise"
  estimatedEmployees Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, companyDomain])
  @@index([userId])
  @@index([companyDomain])
  @@index([engagementScore])
}

model SubsequenceTrigger {
  id         String   @id @default(cuid())
  campaignId String
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  name        String
  description String?

  // Trigger conditions (all must be true)
  conditions Json // { opened: true, clicked: false, replied: false, minOpens: 2, timeWindow: 48 }

  // Action to take
  actionType SubsequenceAction @default(SEND_EMAIL)
  templateId String?
  delayHours Int               @default(24)

  // AI optimization
  aiOptimized  Boolean @default(true)
  bestSendTime Json? // AI determines best time based on prospect activity

  // Stats
  timesTriggered Int   @default(0)
  conversionRate Float @default(0)

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([campaignId])
  @@index([isActive])
}

model SequenceAutomationRule {
  id         String   @id @default(cuid())
  campaignId String
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  name        String
  description String?

  // Trigger definition
  triggerType     AutomationTriggerType
  triggerValue    String? // e.g., URL for link_clicked, number of days for time-based
  timeWindowHours Int? // Time window for condition evaluation

  // Conditions (optional additional filters)
  conditions Json? // { minOpens: 2, industry: "tech", etc. }

  // Actions to execute (in order)
  actions Json // Array of { type, value, delayHours }

  // Execution stats
  timesEvaluated  Int       @default(0)
  timesTriggered  Int       @default(0)
  lastTriggeredAt DateTime?

  // Status
  isActive Boolean @default(true)
  priority Int     @default(0) // Higher priority rules evaluated first

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([campaignId])
  @@index([isActive])
}

model RealtimeNotification {
  id     String @id @default(cuid())
  userId String

  type    RealtimeNotificationType
  title   String
  message String

  // Priority for smart notifications
  priority NotificationPriority @default(MEDIUM)

  // Related entity
  entityType String? // "reply", "bounce", "campaign"
  entityId   String?

  // Delivery
  delivered   Boolean   @default(false)
  deliveredAt DateTime?

  // User interaction
  read      Boolean   @default(false)
  readAt    DateTime?
  clicked   Boolean   @default(false)
  clickedAt DateTime?

  // Sound alert
  playSound   Boolean @default(false)
  soundPlayed Boolean @default(false)

  createdAt DateTime  @default(now())
  expiresAt DateTime? // Auto-delete old notifications

  @@index([userId])
  @@index([delivered])
  @@index([priority])
  @@index([createdAt])
}

// Enums
enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum SubscriptionTier {
  FREE
  STARTER
  PRO
  AGENCY
}

enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  CANCELLED
  PAST_DUE
}

enum CampaignStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  ARCHIVED
}

enum ProspectStatus {
  ACTIVE
  CONTACTED
  CONVERTED
  REPLIED
  BOUNCED
  UNSUBSCRIBED
  COMPLETED
}

enum EmailStatus {
  QUEUED
  SENDING
  SENT
  DELIVERED
  OPENED
  CLICKED
  REPLIED
  BOUNCED
  FAILED
}

enum ResearchDepth {
  BASIC
  STANDARD
  DEEP
}

enum PersonalizationLevel {
  LOW
  MEDIUM
  HIGH
  ULTRA
}

enum IntegrationType {
  GMAIL
  OUTLOOK
  RESEND
  OPENAI
  STRIPE
  HUBSPOT
  SALESFORCE
  PIPEDRIVE
}

enum TeamRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum NotificationType {
  CAMPAIGN_COMPLETED
  CAMPAIGN_PAUSED
  NEW_REPLY
  PROSPECT_IMPORTED
  EMAIL_BOUNCED
  CREDIT_LOW
  SUBSCRIPTION_EXPIRING
  TEAM_INVITE
  SYSTEM_UPDATE
  ACCOUNT_PAUSED
}

enum ScheduleStatus {
  PENDING
  PROCESSING
  SENT
  FAILED
  CANCELLED
}

enum WarmupStage {
  NEW // 0-7 days: 20 emails/day
  WARMING // 8-14 days: 40 emails/day
  WARM // 15-21 days: 60 emails/day
  ACTIVE // 22-30 days: 80 emails/day
  ESTABLISHED // 30+ days: Full limit
}

enum BounceType {
  HARD // Permanent failure (invalid email)
  SOFT // Temporary failure (mailbox full)
  COMPLAINT // Spam complaint
}

enum ReplySentiment {
  POSITIVE // Interested, wants to learn more
  NEUTRAL // Asking questions, needs info
  NEGATIVE // Not interested, remove me
  AUTO_REPLY // Out of office, auto-responder
}

enum ReplyCategory {
  INTERESTED // Wants to schedule call/demo
  NOT_INTERESTED // Not a fit, not now
  QUESTION // Asking for more information
  OUT_OF_OFFICE // Auto-reply
  UNSUBSCRIBE // Remove from list
  REFERRAL // Forwarded to someone else
}

enum CreditTransactionType {
  PURCHASE // Bought credits
  DEDUCTION // Used credits
  REFUND // Refunded credits
  BONUS // Promotional credits
  SUBSCRIPTION // Monthly subscription credits
}

enum CreditType {
  EMAIL
  RESEARCH
}

enum PurchaseStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum DNSStatus {
  UNKNOWN
  PENDING
  VALID
  INVALID
  MISSING
}

enum AlertLevel {
  NONE
  WARNING
  CRITICAL
}

enum WarmupSessionStatus {
  ACTIVE
  PAUSED
  COMPLETED
  FAILED
}

enum WarmupDirection {
  OUTBOUND // Sent from sending account to warmup email
  INBOUND // Sent from warmup email to sending account
}

enum WarmupType {
  POOL // Using 30-email test pool (stages NEW & WARMING)
  PEER // Using peer-to-peer network (stages WARM, ACTIVE, ESTABLISHED)
}

enum SubsequenceAction {
  SEND_EMAIL
  PAUSE_CAMPAIGN
  ADD_TAG
  UPDATE_CRM
  NOTIFY_TEAM
}

enum AutomationTriggerType {
  EMAIL_OPENED
  EMAIL_CLICKED
  LINK_CLICKED
  EMAIL_REPLIED
  NOT_OPENED
  NOT_REPLIED
  TIME_ELAPSED
  ENGAGEMENT_SCORE
}

enum RealtimeNotificationType {
  NEW_REPLY
  HOT_LEAD
  INTERESTED_PROSPECT
  QUESTION_RECEIVED
  BOUNCE_ALERT
  SPAM_COMPLAINT
  CAMPAIGN_MILESTONE
  DAILY_SUMMARY
  CAMPAIGN_PAUSED
  ACCOUNT_PAUSED
}

enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// PRODUCTION-READY SCHEMA MIGRATION
// This file shows the changes needed for your existing schema.prisma
// Add these models and update the EmailTemplate model as shown below

// NEW: Template type enum
enum TemplateType {
  TEXT // Plain text with variables
  VISUAL // Rich visual with drag-and-drop blocks
  HTML // Custom HTML code
}

// NEW: Template categories for organization
model TemplateCategory {
  id          String  @id @default(cuid())
  name        String  @unique // "Cold Outreach", "Follow Up", "Meeting Request"
  slug        String  @unique // "cold-outreach", "follow-up", "meeting-request"
  description String?
  icon        String? // Lucide icon name: "Mail", "Calendar", "Users"
  color       String  @default("#3b82f6") // Hex color for UI
  order       Int     @default(0) // Display order

  // Industry grouping
  industry String? // Group categories by industry: "saas", "ecommerce", etc.

  // Category can have templates
  templates TemplateInCategory[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([industry])
  @@index([slug])
}

// NEW: Many-to-many relationship between templates and categories
model TemplateInCategory {
  id         String           @id @default(cuid())
  templateId String
  template   EmailTemplate    @relation(fields: [templateId], references: [id], onDelete: Cascade)
  categoryId String
  category   TemplateCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([templateId, categoryId])
  @@index([templateId])
  @@index([categoryId])
}

// NEW: Block-based template building
model TemplateBlock {
  id         String        @id @default(cuid())
  templateId String
  template   EmailTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  blockType BlockType
  order     Int // Order in the template
  content   Json // Block-specific content (text, image URL, button text, etc.)
  styling   Json? // Block-specific styles (colors, fonts, spacing)

  // Configuration
  config Json? // Additional block configuration

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
  @@index([order])
}

// NEW: Block types for drag-and-drop editor
enum BlockType {
  HEADER // Hero header with title and subtitle
  PARAGRAPH // Text content with rich formatting
  IMAGE // Image with optional caption
  BUTTON // Call-to-action button
  DIVIDER // Horizontal line separator
  SIGNATURE // Email signature block
  PERSONALIZATION // Dynamic personalization field {{firstName}}
  SOCIAL_LINKS // Social media icons/links
  SPACER // Vertical spacing
  COLUMNS // Multi-column layout
  LIST // Bullet or numbered list
  QUOTE // Blockquote styling
  CODE // Code snippet
}

// NEW: AI template generation history
model TemplateGenerationHistory {
  id     String @id @default(cuid())
  userId String

  // Generation details
  prompt   String  @db.Text // User's prompt
  industry String? // Selected industry
  purpose  String? // "cold-outreach", "follow-up", etc.
  tone     String? // "professional", "casual", "friendly"

  // AI response
  aiModel          String // "gpt-4", "claude-3"
  generatedName    String // AI-generated template name
  generatedSubject String
  generatedBody    String @db.Text

  // Metadata
  templateId String? // If user saved the generated template
  saved      Boolean @default(false)
  quality    Int? // 1-5 star rating from user

  // Generation context
  context Json? // Additional context like company info, recipient details

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([saved])
  @@index([createdAt])
}

// ============================================
// SEQUENCE MANAGEMENT SYSTEM
// ============================================

model Sequence {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name        String
  description String?
  status      SequenceStatus @default(DRAFT)

  // Timing settings
  timezone            String  @default("America/New_York")
  sendInBusinessHours Boolean @default(true)
  businessHoursStart  String  @default("09:00")
  businessHoursEnd    String  @default("17:00")
  businessDays        Int[]   @default([1, 2, 3, 4, 5])

  // Deliverability
  dailySendLimit       Int     @default(50)
  minDelayBetweenSends Int     @default(60)
  trackOpens           Boolean @default(true)
  trackClicks          Boolean @default(true)

  // Multi-channel
  enableLinkedIn Boolean @default(false)
  enableCalls    Boolean @default(false)
  enableTasks    Boolean @default(false)

  // A/B Testing
  enableABTesting    Boolean      @default(false)
  abTestWinnerMetric ABTestMetric @default(REPLY_RATE)
  abTestSampleSize   Int          @default(20)
  abTestDuration     Int          @default(48)

  // AI Settings
  aiOptimizeSendTime Boolean @default(true)
  aiPersonalization  Boolean @default(true)
  toneOfVoice        String  @default("professional")

  // Cached stats
  totalSteps     Int    @default(0)
  totalEnrolled  Int    @default(0)
  totalCompleted Int    @default(0)
  totalExited    Int    @default(0)
  avgOpenRate    Float?
  avgReplyRate   Float?
  avgClickRate   Float?

  // Organization
  folderId String?
  folder   SequenceFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)
  tags     String[]        @default([])

  // Relationships
  steps       SequenceStep[]
  enrollments SequenceEnrollment[]
  abVariants  SequenceABVariant[]
  automations SequenceAutomation[]

  archivedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([folderId])
}

model SequenceStep {
  id         String   @id @default(cuid())
  sequenceId String
  sequence   Sequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)

  order    Int
  stepType StepType @default(EMAIL)

  // Timing
  delayValue Int       @default(1)
  delayUnit  DelayUnit @default(DAYS)

  // Email fields
  subject    String?
  body       String? @db.Text
  bodyHtml   String? @db.Text
  templateId String?

  // Personalization
  variables      Json?
  spintaxEnabled Boolean @default(false)

  // Conditions
  conditions    Json?
  skipIfReplied Boolean @default(true)
  skipIfBounced Boolean @default(true)
  isEnabled     Boolean @default(true)

  // LinkedIn fields
  linkedInAction  LinkedInAction?
  linkedInMessage String?         @db.Text

  // Call fields
  callScript   String? @db.Text
  callDuration Int?

  // Task fields
  taskTitle       String?
  taskDescription String?       @db.Text
  taskPriority    TaskPriority? @default(MEDIUM)

  reviewNote     String?
  estimatedTime  Int?
  requireProof   Boolean @default(false)
  bestTimeToCall String?
  callOutcome    String?
  useInMail      Boolean @default(false)
  dailyLimit     Int?

  // Stats
  sent      Int @default(0)
  delivered Int @default(0)
  opened    Int @default(0)
  clicked   Int @default(0)
  replied   Int @default(0)
  bounced   Int @default(0)

  internalNotes String? @db.Text

  // Relationships
  variants   SequenceStepVariant[]
  executions SequenceStepExecution[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sequenceId, order])
  @@index([sequenceId])
}

model SequenceStepVariant {
  id     String       @id @default(cuid())
  stepId String
  step   SequenceStep @relation(fields: [stepId], references: [id], onDelete: Cascade)

  variantName String
  weight      Int    @default(50)

  subject String?
  body    String? @db.Text

  // Stats
  sent    Int @default(0)
  opened  Int @default(0)
  clicked Int @default(0)
  replied Int @default(0)

  isWinner         Boolean   @default(false)
  winnerSelectedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stepId])
}

model SequenceABVariant {
  id         String   @id @default(cuid())
  sequenceId String
  sequence   Sequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)

  variantName String
  description String?
  weight      Int     @default(50)
  overrides   Json?

  enrolled  Int @default(0)
  completed Int @default(0)
  replied   Int @default(0)

  isWinner Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sequenceId])
}

model SequenceEnrollment {
  id         String   @id @default(cuid())
  sequenceId String
  sequence   Sequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)

  prospectId String

  status      EnrollmentStatus @default(ACTIVE)
  currentStep Int              @default(0)
  variantId   String?

  enrolledAt  DateTime  @default(now())
  nextStepAt  DateTime?
  completedAt DateTime?
  pausedAt    DateTime?

  exitReason ExitReason?
  exitedAt   DateTime?

  resumedAt        DateTime?
  linksClicked     Int       @default(0)
  currentStepIndex Int       @default(0)
  lastActivityAt   DateTime?
  metadata         Json?

  emailsSent    Int       @default(0)
  emailsOpened  Int       @default(0)
  emailsClicked Int       @default(0)
  replied       Boolean   @default(false)
  repliedAt     DateTime?

  executions SequenceStepExecution[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sequenceId, prospectId])
  @@index([sequenceId])
  @@index([prospectId])
  @@index([status])
  @@index([nextStepAt])
}

model SequenceStepExecution {
  id           String             @id @default(cuid())
  enrollmentId String
  enrollment   SequenceEnrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  stepId       String
  step         SequenceStep       @relation(fields: [stepId], references: [id], onDelete: Cascade)

  status    ExecutionStatus @default(PENDING)
  variantId String?

  scheduledAt DateTime?
  executedAt  DateTime?

  // Email tracking
  messageId String?
  opened    Boolean   @default(false)
  openedAt  DateTime?
  clicked   Boolean   @default(false)
  clickedAt DateTime?
  replied   Boolean   @default(false)
  repliedAt DateTime?
  bounced   Boolean   @default(false)
  bouncedAt DateTime?
  metadata  Json?

  errorMessage String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([enrollmentId])
  @@index([stepId])
  @@index([status])
}

model SequenceAutomation {
  id         String   @id @default(cuid())
  sequenceId String
  sequence   Sequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)

  name        String
  description String?
  isActive    Boolean @default(true)

  trigger       AutomationTrigger
  triggerConfig Json?
  conditions    Json?
  actions       Json

  timesTriggered  Int       @default(0)
  lastTriggeredAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sequenceId])
}

model SequenceFolder {
  id       String  @id @default(cuid())
  userId   String
  name     String
  color    String  @default("#3b82f6")
  icon     String  @default("Folder")
  parentId String?

  parent    SequenceFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children  SequenceFolder[] @relation("FolderHierarchy")
  sequences Sequence[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([parentId])
}

model SequenceTemplate {
  id       String  @id @default(cuid())
  userId   String?
  isSystem Boolean @default(false)

  name        String
  description String?
  category    String
  icon        String  @default("Mail")

  steps    Json
  settings Json?

  usageCount Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([category])
  @@index([isSystem])
}

model TemplateVersion {
  id         String        @id @default(cuid())
  templateId String
  template   EmailTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  version Int    @default(1)
  name    String
  subject String
  body    String @db.Text

  // Store snapshot of template data at this version
  description  String?      @db.Text
  category     String?
  industry     String?
  templateType TemplateType @default(TEXT)
  tags         String[]
  thumbnailUrl String?
  colorScheme  Json?
  editorBlocks Json?

  // Version metadata
  changeNote String?  @db.Text
  createdBy  String?
  createdAt  DateTime @default(now())

  @@unique([templateId, version])
  @@index([templateId])
  @@index([createdAt])
}

// ENUMS
enum SequenceStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  ARCHIVED
}

enum StepType {
  EMAIL
  LINKEDIN_VIEW
  LINKEDIN_CONNECT
  LINKEDIN_MESSAGE
  CALL
  TASK
  DELAY
  CONDITION

  AB_SPLIT
  WAIT_UNTIL
  EXIT_TRIGGER
  MANUAL_REVIEW
  MULTI_CHANNEL_TOUCH
  CONTENT_REFERENCE
  BEHAVIOR_BRANCH
  RANDOM_VARIANT
  VOICEMAIL_DROP
  DIRECT_MAIL
}

enum DelayUnit {
  MINUTES
  HOURS
  DAYS
  WEEKS
}

enum LinkedInAction {
  VIEW_PROFILE
  SEND_CONNECTION
  SEND_MESSAGE
  SEND_INMAIL
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum EnrollmentStatus {
  ACTIVE
  PAUSED
  EXITED
  COMPLETED
  BOUNCED
  REPLIED
  UNSUBSCRIBED
  MANUALLY_REMOVED
}

enum ExitReason {
  COMPLETED
  REPLIED
  BOUNCED
  UNSUBSCRIBED
  MANUAL
  AUTOMATION
  GOAL_MET
}

enum ExecutionStatus {
  PENDING
  SCHEDULED
  SENT
  DELIVERED
  FAILED
  SKIPPED
  TIMEOUT
}

enum AutomationTrigger {
  REPLY_RECEIVED
  POSITIVE_REPLY
  NEGATIVE_REPLY
  NO_OPEN
  NO_REPLY
  LINK_CLICKED
  STEP_COMPLETED
  GOAL_MET
}

enum ABTestMetric {
  OPEN_RATE
  CLICK_RATE
  REPLY_RATE
  POSITIVE_REPLY_RATE
}

model Webhook {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  url    String
  secret String // For HMAC signature verification
  events String[] // Array of event types to subscribe to

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  deliveries WebhookDelivery[]

  @@index([userId])
  @@index([isActive])
}

model WebhookDelivery {
  id        String  @id @default(cuid())
  webhookId String
  webhook   Webhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  eventType String
  payload   Json

  // Delivery tracking
  status      WebhookDeliveryStatus @default(PENDING)
  attempts    Int                   @default(0)
  maxAttempts Int                   @default(3)

  responseStatus Int?
  responseBody   String?
  errorMessage   String?

  nextRetryAt DateTime?
  deliveredAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([webhookId])
  @@index([status])
  @@index([nextRetryAt])
}

enum WebhookDeliveryStatus {
  PENDING
  DELIVERED
  FAILED
  RETRY
}

model IdempotencyCache {
  id     String @id @default(cuid())
  key    String @unique
  userId String

  // Cached response
  statusCode   Int
  responseBody Json

  // Expiry
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([key])
  @@index([expiresAt])
  @@index([userId])
}

// 3. Error Tracking System
model ErrorLog {
  id String @id @default(cuid())

  // Error details
  message   String
  stack     String? @db.Text
  errorType String

  // Context
  userId   String?
  apiKeyId String?
  endpoint String?
  method   String?

  // Request details
  requestBody    Json?
  responseStatus Int?

  // Environment
  userAgent String?
  ipAddress String?

  // Grouping
  fingerprint String // Hash of error for grouping
  count       Int    @default(1)

  // Status
  resolved   Boolean   @default(false)
  resolvedAt DateTime?
  resolvedBy String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([fingerprint])
  @@index([userId])
  @@index([resolved])
  @@index([createdAt])
}

// 4. Security Headers Tracking (optional but recommended)
model SecurityEvent {
  id String @id @default(cuid())

  eventType String // "rate_limit_exceeded", "invalid_api_key", "suspicious_activity"
  userId    String?
  apiKeyId  String?

  ipAddress String
  userAgent String?
  endpoint  String?

  severity String // "low", "medium", "high", "critical"
  details  Json?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([apiKeyId])
  @@index([eventType])
  @@index([severity])
  @@index([createdAt])
}

model UserSettings {
  id          String   @id @default(cuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  preferences Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
}

enum EmailType {
  WARMUP // Peer-to-peer warmup emails
  CAMPAIGN // Real campaign emails to prospects
}

enum RetryStatus {
  PENDING // Waiting for next retry
  PROCESSING // Currently being retried
  SUCCEEDED // Successfully sent
  FAILED // Permanently failed
  CANCELLED // Manually cancelled
}

// ============================================================
// APPEND THESE TO YOUR EXISTING SCHEMA.PRISMA FILE
// These are the new models needed for enterprise-grade warmup
// ============================================================

// Note: WarmupThread model has been moved earlier in the schema (after WarmupInteraction)

// 2. ACCOUNT REPUTATION PROFILE
model ReputationProfile {
  id String @id @default(cuid())

  accountId String         @unique
  account   SendingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Domain analysis
  domainAge        Int? // Days since domain registration
  domainReputation Float   @default(50.0) // 0-100 score
  hasSpfRecord     Boolean @default(false)
  hasDkimRecord    Boolean @default(false)
  hasDmarcRecord   Boolean @default(true)

  // ESP Detection
  espType          String? // "gmail", "outlook", "yahoo", "custom"
  espConfiguration Json? // ESP-specific settings

  // Sending history analysis
  totalEmailsSent    Int   @default(0)
  lifetimeBounceRate Float @default(0.0)
  lifetimeOpenRate   Float @default(0.0)
  lifetimeReplyRate  Float @default(0.0)
  lifetimeSpamRate   Float @default(0.0)

  // Risk assessment
  riskScore      Float          @default(50.0) // 0-100, higher = riskier
  reputationTier ReputationTier @default(MEDIUM)

  // Warmup strategy
  recommendedDailyLimit Int    @default(20)
  currentWarmupStage    String @default("initial") // "initial", "building", "established", "mature"
  daysInWarmup          Int    @default(0)

  // Industry & role
  industry    String? // "tech", "finance", "healthcare", "marketing", etc.
  accountRole AccountRole @default(NEUTRAL)

  // Deliverability tracking
  primaryInboxRate Float @default(0.0) // % landing in primary
  promotionsRate   Float @default(0.0) // % landing in promotions
  spamRate         Float @default(0.0) // % landing in spam

  // Last analysis
  lastAnalyzedAt DateTime?
  nextAnalysisAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reputationTier])
  @@index([accountRole])
  @@index([espType])
  @@index([industry])
  @@index([nextAnalysisAt])
}

enum ReputationTier {
  PRISTINE // Perfect reputation, very careful warmup
  HIGH // Good reputation
  MEDIUM // Average reputation
  LOW // Poor reputation, aggressive recovery
  CRITICAL // Severe issues, intensive care
}

enum AccountRole {
  BUSINESS // Sends more, initiates conversations
  CUSTOMER // Receives more, replies more
  NEUTRAL // Balanced sending/receiving
}

// 3. INBOX PLACEMENT TRACKING
model InboxPlacement {
  id String @id @default(cuid())

  accountId String
  account   SendingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Placement detection
  emailLogId          String?
  warmupInteractionId String?

  // Folder detection
  detectedFolder InboxFolder
  espType        String // "gmail", "outlook", "yahoo"

  // Detection metadata
  detectionMethod String // "imap_folder", "api", "manual"
  confidence      Float  @default(1.0) // 0-1, how sure we are

  // Context
  subjectLine  String?
  contentScore Float? // Spam likelihood score

  createdAt DateTime @default(now())

  @@index([accountId])
  @@index([detectedFolder])
  @@index([createdAt])
  @@index([espType])
}

enum InboxFolder {
  PRIMARY // Gmail primary, Outlook inbox focused
  PROMOTIONS // Gmail promotions tab
  SOCIAL // Gmail social tab
  SPAM // Spam/junk folder
  TRASH // Deleted
  UNKNOWN // Couldn't detect
}

// 4. CONTENT TEMPLATES & SPAM SCORES
model ContentTemplate {
  id String @id @default(cuid())

  // Template info
  topic    String // "project_update", "meeting_request", etc.
  industry String? // Optional industry specialization

  // Template content
  subjectLine  String
  bodyTemplate String @db.Text // With {{variables}}

  // Template characteristics
  wordCount      Int
  hasLinks       Boolean @default(false)
  hasAttachments Boolean @default(false)
  formalityLevel String  @default("professional") // "casual", "professional", "formal"

  // Performance tracking
  timesUsed    Int   @default(0)
  avgOpenRate  Float @default(0.0)
  avgReplyRate Float @default(0.0)
  spamScore    Float @default(0.0) // 0-100, lower is better

  // Spam triggers detected
  spamTriggers String[] // Array of detected spam words

  // Status
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([topic])
  @@index([industry])
  @@index([isActive])
  @@index([spamScore])
}

// 5. DYNAMIC STRATEGY ADJUSTMENTS
model StrategyAdjustment {
  id String @id @default(cuid())

  accountId String
  account   SendingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Trigger reason
  trigger  String // "spam_detected", "low_engagement", "bounce_spike", "manual"
  severity AdjustmentSeverity

  // Adjustments made
  previousDailyLimit Int
  newDailyLimit      Int

  previousStrategy Json? // Previous warmup settings
  newStrategy      Json // New warmup settings

  // Impact tracking
  affectedSessions  Int  @default(0)
  estimatedDuration Int? // Days until adjustment reverses

  // Status
  isActive     Boolean   @default(true)
  autoRevertAt DateTime?

  createdAt  DateTime  @default(now())
  revertedAt DateTime?

  @@index([accountId])
  @@index([isActive])
  @@index([autoRevertAt])
  @@index([trigger])
}

enum AdjustmentSeverity {
  MINOR // Small tweaks
  MODERATE // Significant changes
  MAJOR // Drastic reduction
  EMERGENCY // Immediate halt
}

// 6. PRIVATE POOL MEMBERSHIPS
model PoolMembership {
  id String @id @default(cuid())

  accountId String
  account   SendingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  poolId String
  pool   WarmupPool @relation(fields: [poolId], references: [id], onDelete: Cascade)

  // Membership status
  status       PoolMemberStatus @default(ACTIVE)
  joinedAt     DateTime         @default(now())
  lastActiveAt DateTime?

  // Contribution tracking
  emailsSent     Int @default(0)
  emailsReceived Int @default(0)
  repliesSent    Int @default(0)

  // Pool performance
  poolEngagementRate Float @default(0.0)

  leftAt DateTime?

  @@unique([accountId, poolId])
  @@index([poolId])
  @@index([status])
  @@index([lastActiveAt])
}

enum PoolMemberStatus {
  ACTIVE // Actively participating
  INACTIVE // Temporarily inactive
  SUSPENDED // Suspended due to issues
  LEFT // Left the pool
}

model WarmupPool {
  id String @id @default(cuid())

  // Pool configuration
  name        String
  description String?

  // Pool criteria
  reputationTier ReputationTier? // If set, only this tier allowed
  industry       String? // If set, only this industry allowed
  espType        String? // If set, only this ESP type allowed
  minDomainAge   Int? // Minimum domain age in days

  // Pool rules
  maxMembers    Int   @default(1000)
  minEngagement Float @default(0.5) // Minimum engagement rate required

  // Pool type
  isPrivate Boolean @default(false)
  isDefault Boolean @default(false)

  // Pool stats
  activeMembers Int   @default(0)
  avgOpenRate   Float @default(0.0)
  avgReplyRate  Float @default(0.0)

  members PoolMembership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reputationTier])
  @@index([industry])
  @@index([isDefault])
}

// 7. SPAM TRIGGER DICTIONARY
model SpamTrigger {
  id String @id @default(cuid())

  // Trigger info
  word     String @unique
  severity Float  @default(5.0) // 0-10, impact on spam score
  category String // "urgency", "money", "free_offer", "clickbait", etc.

  // Context
  explanation String?
  alternative String? // Suggested alternative

  // Stats
  timesDetected Int @default(0)

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([severity])
  @@index([isActive])
}

model ProcessedWarmupEmail {
  id          String   @id @default(cuid())
  messageId   String
  accountId   String
  warmupId    String?
  threadId    String?
  sessionId   String?
  processedAt DateTime @default(now())

  sendingAccount SendingAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([messageId, accountId])
  @@index([accountId])
  @@index([warmupId])
  @@index([threadId])
  @@index([processedAt])
}
